#pragma once

#include <asmgrader/api/asm_function.hpp>
#include <asmgrader/api/asm_symbol.hpp>
#include <asmgrader/api/expr_inspection.hpp>
#include <asmgrader/api/stringize_fwd.hpp>
#include <asmgrader/common/error_types.hpp>
#include <asmgrader/common/formatters/unknown.hpp>
#include <asmgrader/common/static_string.hpp>
#include <asmgrader/logging.hpp>
#include <asmgrader/meta/concepts.hpp>

#include <boost/type_index.hpp>
#include <fmt/format.h>
#include <fmt/ranges.h>
#include <libassert/assert.hpp>
#include <range/v3/action/take_while.hpp>
#include <range/v3/algorithm/contains.hpp>
#include <range/v3/algorithm/find.hpp>
#include <range/v3/algorithm/find_if_not.hpp>
#include <range/v3/range/access.hpp>
#include <range/v3/range/concepts.hpp>
#include <range/v3/view/drop_while.hpp>
#include <range/v3/view/take_while.hpp>

#include <array>
#include <cctype>
#include <concepts>
#include <cstddef>
#include <cwctype>
#include <functional>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <variant>
#include <vector>

namespace asmgrader {

/// Types and other utilities for representing expressions used in REQUIRE* statements
namespace exprs {

enum class ArityKind { Nullary = 0, Unary, Binary, Ternary };

template <typename OpFn, StaticString Rep, typename... Args>
struct NAryOp
{
    // NOLINTNEXTLINE(readability-identifier-naming)
    NAryOp(std::tuple<Args...> args_, std::array<std::string_view, sizeof...(Args)> arg_strs_)
        : args{std::move(args_)}
        , arg_strs{std::move(arg_strs_)} {}

    std::tuple<Args...> args;
    std::array<std::string_view, sizeof...(Args)> arg_strs;

    using EvalResT = std::decay_t<std::invoke_result_t<OpFn, Args...>>;

    constexpr EvalResT eval() const { return std::apply(OpFn{}, args); }

    static constexpr std::string_view raw_str = Rep;

    static constexpr ArityKind arity{sizeof...(Args)};
};

/// For argument deduction purposes
template <template <typename...> typename Op, typename... Args>
constexpr auto make(std::array<std::string_view, sizeof...(Args)> arg_strs, Args&&... args) {
    // note: lack of forward<> in Op tpack is intentional
    //   if Args...[i]&& is an lvalue ref, we want to keep it as such
    //   if Args...[i]&& is an rvalue, we want to store an lvalue
    return Op<Args...>{{std::forward<Args>(args)...}, arg_strs};
}

/// \overload
template <template <typename...> typename Op, typename... Args>
constexpr auto make(Args&&... args) {
    return make<Op>({}, std::forward<Args>(args)...);
}

template <typename Args>
using Noop = NAryOp<std::identity, "", Args>;

template <typename Arg>
using LogicalNot = NAryOp<std::logical_not<>, "!", Arg>;

template <typename Lhs, typename Rhs>
using Equal = NAryOp<std::equal_to<>, "==", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using NotEqual = NAryOp<std::not_equal_to<>, "!=", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using Less = NAryOp<std::less<>, "<", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using LessEqual = NAryOp<std::less_equal<>, "<=", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using Greater = NAryOp<std::greater<>, ">", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using GreaterEqual = NAryOp<std::greater_equal<>, ">=", Lhs, Rhs>;

template <typename T>
concept Operator = requires(T op) {
    { T::raw_str } -> std::convertible_to<std::string_view>;
    { T::arity } -> std::convertible_to<ArityKind>;
    { op.args } -> IsTemplate<std::tuple>;
    { op.arg_strs } -> std::convertible_to<std::array<std::string_view, static_cast<std::size_t>(T::arity)>>;
    { op.eval() };
} && std::tuple_size_v<decltype(T::args)> == static_cast<std::size_t>(T::arity);

// sanity checks
static_assert(Operator<LogicalNot<int>>);

/// Representation of an expression with all components stringized
struct ExpressionRepr
{
    // FIXME: compiler no like [deletes default ctor of variant]
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
    struct Repr
    {
        /// Representation of the type as by stringize
        std::string repr;

        /// Original string (should be as generated by the # prepocessor operator)
        std::string_view raw_str;

        using TokenStream = std::vector<asmgrader::inspection::Token>;
        TokenStream raw_str_tokens;

        /// This field will probably never be used, but it might be nice later for debug info
        boost::typeindex::type_index type_index;

        /// A heuristic of what type the value is. May not always be perfectly accurate
        enum class Type { String, Integer, Floating, Other };
        Type kind;

        /// This might be a false positive for expressions that return an rvalue
        bool is_lvalue;
    };

    struct Value
    {
        Repr repr;
    };

    // forward decl for use in Expression
    struct Operator;

    using Expression = std::variant<Value, Operator>;

    /// The `str` field is the representation of the operator (e.g., '+', '!=').
    struct Operator
    {
        Repr repr;

        /// List of operands. Operator arity = `operands.size()` *Probably* will never support ops with higher arity
        /// than binary, but it's just a vector for future-proofing.
        std::vector<Expression> operands;
    };

    Expression expression;
};

} // namespace exprs

namespace stringize {

/// Serializes strings with surrounding quotes ("") and escapes characters.
///
/// e.g., "abc\t123\n"
template <std::convertible_to<std::string_view> Str>
inline std::string stringize(const Str& str) {
    // converting to string_view in case the formatter for the type of Str does not allow '?'
    return fmt::format("{:?}", std::string_view{str});
}

// TODO: Little bit unDRY

template <typename T>
inline std::string stringize(const AsmSymbolResult<T> symbol_res) {
    if (symbol_res.has_error()) {
        ASSERT(symbol_res.error() == ErrorKind::UnresolvedSymbol);
        return fmt::format("Symbol {} could not be resolved", symbol_res.symbol_name);
    }
    return fmt::format("({} = {})", symbol_res.symbol_name, try_stringize(symbol_res.value()));
}

template <typename Ret, typename... Ts>
inline std::string stringize(const AsmFunctionResult<Ret, Ts...>& fn_res) {
    std::array stringized_args = std::apply(
        []<typename... Args>(Args&&... args) { return std::array{try_stringize(std::forward<Args>(args))...}; },
        fn_res.args);

    return fmt::format("{}({})", fn_res.function_name, fmt::join(stringized_args, ", "));
}

/// I love this name
template <typename Arg>
concept Stringizable = requires(Arg arg) {
    { stringize(arg) } -> std::convertible_to<std::string>;
};

/// Attempt to stringize arg. If a matching overload is not found, will
/// delegate serialization to \ref format_or_unknown
template <typename Arg>
inline std::string try_stringize(Arg&& arg) {
    if constexpr (Stringizable<Arg>) {
        return stringize(std::forward<Arg>(arg));
    } else {
        return format_or_unknown(std::forward<Arg>(arg));
    }
}

} // namespace stringize

// TODO: Might want to optimize by making more use of views, as the primary use case will be in REQUIRE*

template <exprs::Operator Op>
class Requirement
{
public:
    static constexpr auto default_description = "<no description provided>";

    [[deprecated("====================================================================================================="
                 "=========================================================== !!!!!!!!!!!!!!!!! "
                 "Please consider providing a requirement description by using REQUIRE(..., \"<description here>\")"
                 " !!!!!!!!!!!!!!!!! "
                 "====================================================================================================="
                 "=========================================================== ")]]
    explicit Requirement(Op op)
        : Requirement(op, default_description) {}

    explicit Requirement(Op op, std::string description)
        : op_{op}
        , description_{std::move(description)} {}

    std::string get_description() const { return description_; }

    bool get_res() const {
        static_assert(
            requires { static_cast<bool>(std::declval<std::invoke_result_t<decltype(&Op::eval), Op>>()); },
            "Requirement expressions must be convertible to bool (for now)");

        return static_cast<bool>(op_.eval());
    }

    exprs::ExpressionRepr get_expr_repr() const {
        // Only supporting a single unary or binary op for now, so this is pretty simple

        exprs::ExpressionRepr result{};

        using enum exprs::ArityKind;

        if constexpr (Op::arity != Unary && Op::arity != Binary) {
            UNIMPLEMENTED("Operators that are not unary or binary are not supported");
        }

        // Special case for noop to just get the value
        if constexpr (IsTemplate<Op, exprs::Noop>) {
            using Arg0T = std::tuple_element<0, decltype(op_.args)>;
            const auto& arg0_str = op_.arg_strs.at(0);

            result.expression = make_expr_value<Arg0T>(std::get<0>(op_.args), arg0_str);
        } else {
            using ResultT = decltype(op_.eval());
            exprs::ExpressionRepr::Repr repr{.repr = stringize::try_stringize(op_.eval()), //
                                             .raw_str = std::string{Op::raw_str},
                                             .type_index = boost::typeindex::type_id_with_cvr<ResultT>(),
                                             .kind = deduce_kind<ResultT>(),
                                             .is_lvalue = false};

            std::vector operands = std::apply(
                [this]<typename... TupleTypes>(const std::tuple<TupleTypes...>& /*for type deduction*/) {
                    return [this]<typename... Args>(Args&&... args) {
                        std::size_t idx = 0;
                        return std::vector{
                            make_expr_value<TupleTypes>(std::forward<Args>(args), op_.arg_strs.at(idx++))...};
                    };
                }(op_.args),
                op_.args);

            result.expression =
                exprs::ExpressionRepr::Operator{.repr = std::move(repr), .operands = std::move(operands)};
        }

        return result;
    }

private:
    template <typename Val>
    static consteval exprs::ExpressionRepr::Repr::Type deduce_kind() {
        using Repr = exprs::ExpressionRepr::Repr;
        using enum Repr::Type;

        // TODO: Literal deduction (starts with a digit, or a '.', or '"', or R", etc.)
        using DecayT = std::decay_t<Val>;

        if constexpr (std::convertible_to<DecayT, std::string_view>) {
            return String;
        } else if constexpr (std::integral<DecayT>) {
            return Integer;
        } else if constexpr (std::floating_point<DecayT>) {
            return Floating;
        } else {
            return Other;
        }
    }

    template <typename OrigType, typename Val>
    exprs::ExpressionRepr::Repr make_repr_value(Val&& value, std::string_view raw_str, bool is_lvalue) const {

        return {.repr = stringize::try_stringize(std::forward<Val>(value)),
                .raw_str = std::string{raw_str},
                .type_index = boost::typeindex::type_id_with_cvr<OrigType>(),
                .kind = deduce_kind<OrigType>(),
                .is_lvalue = is_lvalue};
    }

    // template <typename Val>
    // exprs::ExpressionRepr::Expression make_expr_value(Val& value, std::string_view raw_str) const {
    //     using Value = exprs::ExpressionRepr::Value;
    //
    //     return Value{.repr = make_repr_value(value, raw_str, true)};
    // }

    template <typename OrigType, typename Val>
    exprs::ExpressionRepr::Expression make_expr_value(Val&& value, std::string_view raw_str) const {
        using Value = exprs::ExpressionRepr::Value;

        bool is_lvalue{};

        if constexpr (std::is_lvalue_reference_v<OrigType>) {
            is_lvalue = true;
        } else {
            ASSERT(!std::is_reference_v<OrigType>, boost::typeindex::type_id_with_cvr<Val>());
            is_lvalue = false;
        }

        return Value{.repr = make_repr_value<OrigType>(std::forward<Val>(value), raw_str, is_lvalue)};
    }

    Op op_;
    std::string description_;
};

} // namespace asmgrader
