#pragma once

#include <asmgrader/api/asm_function.hpp>
#include <asmgrader/api/asm_symbol.hpp>
#include <asmgrader/api/stringize_fwd.hpp>
#include <asmgrader/common/error_types.hpp>
#include <asmgrader/common/formatters/unknown.hpp>
#include <asmgrader/common/static_string.hpp>
#include <asmgrader/logging.hpp>
#include <asmgrader/meta/concepts.hpp>

#include <boost/type_index.hpp>
#include <fmt/format.h>
#include <fmt/ranges.h>
#include <libassert/assert.hpp>

#include <array>
#include <concepts>
#include <cstddef>
#include <functional>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <utility>
#include <variant>
#include <vector>

namespace asmgrader {

/// Types and other utilities for representing expressions used in REQUIRE* statements
namespace exprs {

enum class ArityKind { Nullary = 0, Unary, Binary, Ternary };

template <typename OpFn, StaticString Rep, typename... Args>
struct NAryOp
{
    // NOLINTNEXTLINE(readability-identifier-naming)
    NAryOp(std::tuple<Args...> args_, std::array<std::string_view, sizeof...(Args)> arg_strs_)
        : args{std::move(args_)}
        , arg_strs{std::move(arg_strs_)} {}

    std::tuple<Args...> args;
    std::array<std::string_view, sizeof...(Args)> arg_strs;

    using EvalResT = std::decay_t<std::invoke_result_t<OpFn, Args...>>;

    constexpr EvalResT eval() const { return std::apply(OpFn{}, args); }

    static constexpr std::string_view raw_str = Rep;

    static constexpr ArityKind arity{sizeof...(Args)};
};

/// For argument deduction purposes
template <template <typename...> typename Op, typename... Args>
constexpr auto make(std::array<std::string_view, sizeof...(Args)> arg_strs, Args&&... args) {
    // note: lack of forward<> in Op tpack is intentional
    //   if Args...[i]&& is an lvalue ref, we want to keep it as such
    //   if Args...[i]&& is an rvalue, we want to store an lvalue
    return Op<Args...>{{std::forward<Args>(args)...}, arg_strs};
}

/// \overload
template <template <typename...> typename Op, typename... Args>
constexpr auto make(Args&&... args) {
    return make<Op>({}, std::forward<Args>(args)...);
}

template <typename Args>
using Noop = NAryOp<std::identity, "", Args>;

template <typename Arg>
using LogicalNot = NAryOp<std::logical_not<>, "!", Arg>;

template <typename Lhs, typename Rhs>
using Equal = NAryOp<std::equal_to<>, "==", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using NotEqual = NAryOp<std::not_equal_to<>, "!=", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using Less = NAryOp<std::less<>, "<", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using LessEqual = NAryOp<std::less_equal<>, "<=", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using Greater = NAryOp<std::greater<>, ">", Lhs, Rhs>;

template <typename Lhs, typename Rhs>
using GreaterEqual = NAryOp<std::greater_equal<>, ">=", Lhs, Rhs>;

template <typename T>
concept Operator = requires(T op) {
    { T::raw_str } -> std::convertible_to<std::string_view>;
    { T::arity } -> std::convertible_to<ArityKind>;
    { op.args } -> IsTemplate<std::tuple>;
    { op.arg_strs } -> std::convertible_to<std::array<std::string_view, static_cast<std::size_t>(T::arity)>>;
    { op.eval() };
} && std::tuple_size_v<decltype(T::args)> == static_cast<std::size_t>(T::arity);

// sanity checks
static_assert(Operator<LogicalNot<int>>);

/// Representation of an expression with all components stringized
struct ExpressionRepr
{
    struct Repr
    {
        /// Representation of the type as by stringize
        std::string repr;

        /// Original string (should be as generated by the # prepocessor operator)
        std::string raw_str;

        /// This field will probably never be used, but it might be nice later for debug info
        boost::typeindex::type_index type_index;
    };

    // forward decl for use in Expression
    struct Operator;

    /// i.e. a literal or class type temporary constructed in place.
    /// Or a cast a prvalue or xvalue, but there's no sane reason to do that in this context
    struct RValue // NOLINT(fuchsia-multiple-inheritance) - rational: very simple case
    {
        Repr repr;

        enum class Kind { String, Integer, Floating, Other };
        Kind kind;
    };

    struct LValue // NOLINT(fuchsia-multiple-inheritance) - rational: very simple case
    {
        Repr repr;
    };

    using Expression = std::variant<Operator, RValue, LValue>;

    /// The `str` field is the representation of the operator (e.g., '+', '!=').
    struct Operator
    {
        Repr repr;

        /// List of operands. Operator arity = `operands.size()` *Probably* will never support ops with higher arity
        /// than binary, but it's just a vector for future-proofing.
        std::vector<Expression> operands;
    };

    Expression expression;
};

} // namespace exprs

namespace stringize {

/// Serializes strings with surrounding quotes ("") and escapes characters.
///
/// e.g., "abc\t123\n"
template <std::convertible_to<std::string_view> Str>
inline std::string stringize(const Str& str) {
    // converting to string_view in case the formatter for the type of Str does not allow '?'
    return fmt::format("{:?}", std::string_view{str});
}

// TODO: Little bit unDRY

template <typename T>
inline std::string stringize(const AsmSymbolResult<T> symbol_res) {
    if (symbol_res.has_error()) {
        ASSERT(symbol_res.error() == ErrorKind::UnresolvedSymbol);
        return fmt::format("Symbol {} could not be resolved", symbol_res.symbol_name);
    }
    return fmt::format("({} = {})", symbol_res.symbol_name, try_stringize(symbol_res.value()));
}

template <typename Ret, typename... Ts>
inline std::string stringize(const AsmFunctionResult<Ret, Ts...>& fn_res) {
    std::array stringized_args = std::apply(
        []<typename... Args>(Args&&... args) { return std::array{try_stringize(std::forward<Args>(args))...}; },
        fn_res.args);

    return fmt::format("{}({})", fn_res.function_name, fmt::join(stringized_args, ", "));
}

/// I love this name
template <typename Arg>
concept Stringizable = requires(Arg arg) {
    { stringize(arg) } -> std::convertible_to<std::string>;
};

/// Attempt to stringize arg. If a matching overload is not found, will
/// delegate serialization to \ref format_or_unknown
template <typename Arg>
inline std::string try_stringize(Arg&& arg) {
    if constexpr (Stringizable<Arg>) {
        return stringize(std::forward<Arg>(arg));
    } else {
        return format_or_unknown(std::forward<Arg>(arg));
    }
}

} // namespace stringize

// TODO: Might want to optimize by making more use of views, as the primary use case will be in REQUIRE*

template <exprs::Operator Op>
class Requirement
{
public:
    static constexpr auto default_description = "<no description provided>";

    [[deprecated("====================================================================================================="
                 "=========================================================== !!!!!!!!!!!!!!!!! "
                 "Please consider providing a requirement description by using REQUIRE(..., \"<description here>\")"
                 " !!!!!!!!!!!!!!!!! "
                 "====================================================================================================="
                 "=========================================================== ")]]
    explicit Requirement(Op op)
        : Requirement(op, default_description) {}

    explicit Requirement(Op op, std::string description)
        : op_{op}
        , description_{std::move(description)} {}

    std::string get_description() const { return description_; }

    bool get_res() const {
        static_assert(
            requires { static_cast<bool>(std::declval<std::invoke_result_t<decltype(&Op::eval), Op>>()); },
            "Requirement expressions must be convertible to bool (for now)");

        return static_cast<bool>(op_.eval());
    }

    exprs::ExpressionRepr get_expr_repr() const {
        // Only supporting a single unary or binary op for now, so this is pretty simple

        exprs::ExpressionRepr result;

        using enum exprs::ArityKind;

        if constexpr (Op::arity != Unary && Op::arity != Binary) {
            UNIMPLEMENTED("Operators that are not unary or binary are not supported");
        }

        // Special case for noop to just get the value
        if constexpr (IsTemplate<Op, exprs::Noop>) {
            // using Arg0T = std::tuple_element<0, decltype(op_.args)>;
            const auto& arg0_str = op_.arg_strs.at(0);

            result.expression = make_expr_value(std::get<0>(op_.args), arg0_str);
        } else {
            exprs::ExpressionRepr::Repr repr{.repr = "", //
                                             .raw_str = std::string{Op::raw_str},
                                             .type_index = boost::typeindex::type_id_with_cvr<decltype(op_.eval())>()};

            std::vector operands = std::apply(
                [this]<typename... Args>(Args&&... args) {
                    std::size_t idx = 0;
                    return std::vector{make_expr_value(std::forward<Args>(args), op_.arg_strs.at(idx++))...};
                },
                op_.args);

            result.expression =
                exprs::ExpressionRepr::Operator{.repr = std::move(repr), .operands = std::move(operands)};
        }

        return result;
    }

private:
    template <typename Value>
    exprs::ExpressionRepr::Repr make_repr_value(Value&& value, std::string_view raw_str) const {
        return {.repr = stringize::try_stringize(std::forward<Value>(value)),
                .raw_str = std::string{raw_str},
                .type_index = boost::typeindex::type_id_with_cvr<Value>()};
    }

    template <typename Value>
    exprs::ExpressionRepr::Expression make_expr_value(Value& value, std::string_view raw_str) const {
        using LValue = exprs::ExpressionRepr::LValue;

        return LValue{.repr = make_repr_value(value, raw_str)};
    }

    template <typename Value>
    // NOLINTNEXTLINE(cppcoreguidelines-missing-std-forward) - rational: false positive; not a forwarding reference
    exprs::ExpressionRepr::Expression make_expr_value(Value&& value, std::string_view raw_str) const {
        using RValue = exprs::ExpressionRepr::RValue;

        using enum RValue::Kind;

        RValue::Kind kind{};

        using DecayT = std::decay_t<Value>;

        if constexpr (std::convertible_to<DecayT, std::string_view>) {
            kind = String;
        } else if constexpr (std::integral<DecayT>) {
            kind = Integer;
        } else if constexpr (std::floating_point<DecayT>) {
            kind = Floating;
        } else {
            kind = Other;
        }

        // NOLINTNEXTLINE(bugprone-move-forwarding-reference) - rational: false positive; not a forwarding reference
        return RValue{.repr = make_repr_value(std::move(value), raw_str), .kind = kind};
    }

    Op op_;
    std::string description_;
};

} // namespace asmgrader
